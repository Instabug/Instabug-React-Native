import org.apache.tools.ant.taskdefs.condition.Os

project.afterEvaluate {
    // Works for both `bundleReleaseJsAndAssets` and `createBundleReleaseJsAndAssets` and product flavors
    def suffix = 'ReleaseJsAndAssets'
    def bundleTasks = project(':app').tasks.findAll {
        task -> task.name.endsWith(suffix)
    }

    bundleTasks.forEach { task ->
        def name = task.name
        def prefixes = ['bundle', 'createBundle']
        def start = name.startsWith(prefixes[0]) ? prefixes[0].length() : prefixes[1].length()
        def end = name.length() - suffix.length()
        def flavor = name.substring(start, end).uncapitalize()
        def defaultVersion = getDefaultVersion(flavor)



        task.finalizedBy createUploadSourcemapsTask(flavor, defaultVersion.name, defaultVersion.code,task)
    }
}

Task createUploadSourcemapsTask(String flavor, String defaultVersionName, String defaultVersionCode, Task task) {
    def name = 'uploadSourcemaps' + flavor.capitalize()

    // Don't recreate the task if it already exists.
    // This prevents the build from failing in an edge case where the user has
    // both `bundleReleaseJsAndAssets` and `createBundleReleaseJsAndAssets`
    def taskExists = tasks.getNames().contains(name)
    if (taskExists) {
        return tasks.named(name).get()
    }

    def provider = tasks.register(name) {
        group 'instabug'
        description 'Uploads sourcemaps file to Instabug server'
        enabled = isUploadSourcemapsEnabled()

        doLast {
            try {
                def appProject = project(':app')
                def appDir = appProject.projectDir
                def sourceMapFile = getSourceMapFile(appDir, flavor,task)

                def jsProjectDir = rootDir.parentFile
                def instabugDir = new File(['node', '-p', 'require.resolve("instabug-reactnative/package.json")'].execute(null, rootDir).text.trim()).getParentFile()

              def tokenJsFile = new File(instabugDir, 'scripts/find-token.js')
              def inferredToken = executeNodeScript(tokenJsFile, jsProjectDir)

                def appToken = resolveVar('App Token', 'INSTABUG_APP_TOKEN', inferredToken)

                  if (!appToken) {
                    throw new GradleException("‚ùå Unable to infer Instabug token from script: ${tokenShellFile.absolutePath}")
                }
                def versionName = resolveVar('Version Name', 'INSTABUG_VERSION_NAME', defaultVersionName)
                def versionCode = resolveVar('Version Code', 'INSTABUG_VERSION_CODE', defaultVersionCode)

                println "üì¶ Uploading with versionName=${versionName}, versionCode=${versionCode}, appToken=${appToken.take(5)}..."

                exec {
                    def osCompatibility = Os.isFamily(Os.FAMILY_WINDOWS) ? ['cmd', '/c'] : []
                    def args = [
                            'npx', 'instabug', 'upload-sourcemaps',
                            '--platform', 'android',
                            '--file', sourceMapFile.absolutePath,
                            '--token', appToken,
                            '--name', versionName,
                            '--code', versionCode
                    ]

                    commandLine(*osCompatibility, *args)
                }
            } catch (exception) {
                project.logger.error "Failed to upload source map file.\n" +
                        "Reason: ${exception.message}"
                           throw exception

            }
        }
    }

    return provider.get()
}

File getSourceMapFile(File appDir, String flavor, Task task) {
    def defaultFlavorPath = flavor.empty ? 'release' : "${flavor}Release"
    def defaultSourceMapDest = "build/generated/sourcemaps/react/${defaultFlavorPath}/index.android.bundle.map"
    def defaultSourceMapFile = new File(appDir, defaultSourceMapDest)
    def props = task.getProperties()

    def bundleAssetName = props.containsKey("bundleAssetName") ? props.bundleAssetName?.getOrNull() : null
    def jsSourceMapsDir = props.containsKey("jsSourceMapsDir") ? props.jsSourceMapsDir?.getOrNull() : null
    def jsIntermediateSourceMapsDir = props.containsKey("jsIntermediateSourceMapsDir") ? props.jsIntermediateSourceMapsDir?.getOrNull() : null

    if (bundleAssetName && jsSourceMapsDir) {
        def outputSourceMap = new File(jsSourceMapsDir.asFile.absolutePath, "${bundleAssetName}.map")
        if (outputSourceMap.exists()) {
            return outputSourceMap
        }
    }

    if (bundleAssetName && jsIntermediateSourceMapsDir) {
        def packagerOutputSourceMap = new File(jsIntermediateSourceMapsDir.asFile.absolutePath, "${bundleAssetName}.packager.map")
        if (packagerOutputSourceMap.exists()) {
            return packagerOutputSourceMap
        }
    }

    if (defaultSourceMapFile.exists()) {
        return defaultSourceMapFile
    }

    if (flavor.empty) {
         println"Source map file not found at: ${defaultSourceMapFile.absolutePath}. Skipping."
        return null
    }

    def fallbackSourceMapDest = "build/generated/sourcemaps/react/${flavor}/release/index.android.bundle.map"
    def fallbackSourceMapFile = new File(appDir, fallbackSourceMapDest)

  println "Unable to find source map file at: ${defaultSourceMapFile.absolutePath}.\n" +
            "Falling back to ${fallbackSourceMapFile.absolutePath}."

    if (!fallbackSourceMapFile.exists()) {
    println "Fallback source map file not found at: ${fallbackSourceMapFile.absolutePath}. Skipping."
        return null
    }

    return fallbackSourceMapFile
}

/**
 * Infers the app version to use in source map upload based on the flavor.
 * This is needed since different flavors may have different version codes and names (e.g. version suffixes).
 *
 * It checks the version for the flavor's variant.
 * If no variant is found it falls back to the app's default config.
 *
 *
 * @param flavor The flavor to get the app version for.
 * @return A map containing the version code and version name.
 */
Map<String, String> getDefaultVersion(String flavor) {
    def appProject = project(':app')
    def defaultConfig = appProject.android.defaultConfig

    def variants = appProject.android.applicationVariants

    // uncapitalize is used to turn "Release" into "release" if the flavor is empty
    def variantName = "${flavor}Release".uncapitalize()
    def variant = variants.find { it.name.uncapitalize() == variantName }

    def versionName = variant?.versionName ?: defaultConfig.versionName
    def versionCode = variant?.versionCode ?: defaultConfig.versionCode

    return [name: "${versionName}", code: "${versionCode}"]
}

boolean isUploadSourcemapsEnabled() {
    def envValue = System.getenv('INSTABUG_SOURCEMAPS_UPLOAD_DISABLE')?.toBoolean()
    def defaultValue = true

    return (envValue != null) ? !envValue : defaultValue
}

String resolveVar(String name, String envKey, String defaultValue) {
    def env = System.getenv()
    def envValue = env.get(envKey)

    if (envValue != null && defaultValue !=null && envValue != defaultValue) {
        project.logger.warn "Environment variable `${envKey}` might have incorrect value, " +
                "make sure this was intentional:\n" +
                "   Environment Value: ${envValue}\n" +
                "   Default Value: ${defaultValue}"
    }

    def value = envValue ?: defaultValue

    if (value == null) {
        throw new InvalidUserDataException("Unable to find ${name}! " +
                "Set the environment variable `${envKey}` and try again.")
    }

    return value
}

static String executeNodeScript(File script, File workingDir) {
    if (!script.exists()) {
        println "Script not found: ${script.absolutePath}"
        return null
    }

    def output = new StringBuffer()
    def error = new StringBuffer()

    try {
        def process = ['node', script.getAbsolutePath()].execute(null, workingDir)
        process.waitForProcessOutput(output, error)

        if (process.exitValue() != 0) {
            println "Script failed with exit code ${process.exitValue()}"
            println "Standard Error:\n${error.toString().trim()}"
            println "Standard Output:\n${output.toString().trim()}"
            return null
        }

        return output.toString().trim()

    } catch (Exception e) {
        println "Exception while executing Node.js script: ${e.message}"
        e.printStackTrace()
        return null
    }
}

static String executeShellScript(File script, File workingDir) {
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        return null
    }

    if (!script.canExecute()) {
        // Try to set executable permission
        script.setExecutable(true)
    }

    def output = new StringBuffer()
    def error = new StringBuffer()

    // Using 'sh' instead of './' to avoid needing exec permission, but keeping chmod above just in case
    def process = ['sh', script.getAbsolutePath()].execute(null, workingDir)
    process?.waitForProcessOutput(output, error)

    if (process.exitValue() != 0) {
        println "Error running script: ${error.toString().trim()}"
        return null
    }

    return output.toString().trim()
}
